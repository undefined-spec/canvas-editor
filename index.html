<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Pratik Discord.JS Canvas</title>
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Open+Sans&family=Inter:wght@400;700&display=swap">
    <style>
        body {
            font-family: 'Roboto', Arial, sans-serif;
            margin: 20px;
            background: linear-gradient(to bottom, #f0f4f8, #e0e8f0);
            color: #202124;
            display: flex;
            gap: 20px;
            min-height: 80vh;
        }

        #controls {
            width: 360px;
            padding: 16px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
        }

        #canvas-wrap {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        canvas {
            border: 1px solid #ccd6dd;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            cursor: grab;
            display: block;
            outline: none;
        }

        label {
            font-size: 14px;
            margin-top: 12px;
            color: #4d5156;
            display: block;
        }

        input,
        select,
        button,
        textarea {
            width: 100%;
            padding: 8px 12px;
            margin-top: 6px;
            box-sizing: border-box;
            border-radius: 8px;
            border: 1px solid #dadce0;
            font-size: 14px;
        }

        input:focus,
        select:focus,
        textarea:focus {
            border-color: #1a73e8;
            outline: none;
        }

        .row {
            display: flex;
            gap: 12px;
        }

        .row .half {
            flex: 1;
        }

        .text-item {
            border: 1px solid #e8eaed;
            padding: 12px;
            margin: 12px 0;
            border-radius: 8px;
            background: #f8f9fa;
            transition: box-shadow .12s;
        }

        .text-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .small-btn {
            width: auto;
            padding: 8px 14px;
            border-radius: 8px;
            background: #1a73e8;
            color: #fff;
            border: 0;
            cursor: pointer;
        }

        .small-btn.grey {
            background: #5f6368;
        }

        .muted {
            color: #5f6368;
            font-size: 13px;
        }

        .export-box {
            background: #202124;
            color: #e8eaed;
            padding: 14px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 220px;
            overflow: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .top-actions {
            display: flex;
            gap: 10px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        #texts-list {
            max-height: 420px;
            overflow: auto;
            padding-right: 6px;
            margin-top: 10px;
        }

        @media (max-width:900px) {
            body {
                flex-direction: column
            }

            #controls {
                width: 100%;
                max-width: 900px
            }
        }

        .credit-box {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px 14px;
            background: #ffffff;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(16, 24, 40, 0.06);
            border: 1px solid rgba(16, 24, 40, 0.04);
            max-width: 820px;
            margin-top: 8px;
        }

        .credit-box .muted.small {
            margin: 0;
            color: #5f6368;
            font-size: 13px;
            text-align: center;
        }

        .credit-box .shu {
            color: #1a73e8;
            font-weight: 700;
        }

        .discord-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            border-radius: 8px;
            text-decoration: none;
            transition: transform .12s ease, box-shadow .12s ease;
        }

        .discord-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(88, 101, 242, 0.18);
        }

        .discord-link svg {
            display: block;
        }

        .section-title {
            margin-top: 14px;
            font-size: 13px;
            color: #3c4043;
            letter-spacing: .3px;
        }

        .hr {
            height: 1px;
            background: #eceff1;
            border: 0;
            margin: 10px 0;
        }
    </style>
</head>

<body>

    <div id="controls" aria-label="Kontrol paneli">
        <h3>Kontroller</h3>

        <label>Genişlik (px)</label>
        <input type="number" id="manual-width" min="50" max="3000" value="800" aria-label="Genişlik">

        <label>Yükseklik (px)</label>
        <input type="number" id="manual-height" min="30" max="3000" value="450" aria-label="Yükseklik">

        <label>Arka Plan Rengi</label>
        <input type="color" id="bg-color" value="#0f1720" aria-label="Arka plan rengi">

        <div class="section-title">Arka Plan Fotoğrafı</div>
        <div class="row">
            <input type="file" id="bg-image-input" accept="image/*" aria-label="Arka plan fotoğrafı seç">
            <button id="apply-bg-image" class="small-btn grey" title="Foto Ekle">Ekle</button>
        </div>
        <div class="row" style="margin-top:8px">
            <select id="bg-fit" class="half" aria-label="Arka plan yerleşimi">
                <option value="cover">Cover (Taşmadan doldur)</option>
                <option value="contain">Contain (Sığdır)</option>
                <option value="stretch">Stretch (Esnet)</option>
            </select>
            <div class="half">
                <label style="margin-top:0">Opaklık</label>
                <input type="range" id="bg-alpha" min="0" max="1" step="0.05" value="1" aria-label="Arka plan opaklığı">
            </div>
        </div>
        <button id="remove-bg-image" class="small-btn grey" style="margin-top:6px">Foto Kaldır</button>

        <div class="top-actions">
            <button id="apply-dims" class="small-btn">Boyutu Uygula</button>
            <button id="add-text" class="small-btn grey">Metin Ekle</button>
            <button id="undo" class="small-btn grey" disabled>Geri Al</button>
            <button id="redo" class="small-btn grey" disabled>İleri Al</button>
        </div>

        <p class="muted">İlk metin varsayılan <b>siyah</b>, diğerleri koyu tonlarda başlar. Çok satır için
            <code>\n</code> kullanın.</p>

        <div class="row">
            <label style="flex:1;margin-top:0">
                <input type="checkbox" id="text-stroke"> Metin Konturu
            </label>
            <label style="flex:1;margin-top:0">
                <input type="checkbox" id="text-shadow"> Metin Gölgesi
            </label>
        </div>

        <div class="hr"></div>
        <div class="muted">Seçili metin: ok tuşlarıyla taşı, <kbd>Shift</kbd> + ok = 10px. <kbd>Delete</kbd> = sil.
            <kbd>Ctrl/Cmd</kbd> + <kbd>Z</kbd>/<kbd>Y</kbd>.</div>

        <div id="texts-list" aria-label="Metin listesi"></div>

        <h4 style="margin-top:10px">Export (Discord.js)</h4>
        <div class="export-box" id="export-code">// Metinleri ekleyin, düzenleyin ve 'Tümünü Kopyala'ya basın.</div>

        <div class="row" style="margin-top:10px">
            <button id="copy-all" class="small-btn">Tümünü Kopyala</button>
            <button id="download-png" class="small-btn grey">PNG İndir</button>
        </div>
        <p id="copy-feedback" class="muted" style="display:none;margin-top:8px">Kopyalandı!</p>
    </div>

    <div id="canvas-wrap">
        <canvas id="canvas" width="800" height="450" role="img" aria-label="Canvas önizleme" tabindex="0"></canvas>

        <div class="credit-box" role="contentinfo" aria-label="Credit and Discord invite">
            <div class="credit-text" style="flex:1">
                <p class="muted small" style="margin:0; text-align:center">
                    Metinleri sürükleyin. Listeden düzenleyin, ortalayın veya silin.
                </p>
                <p class="muted small" style="margin:6px 0 0 0; text-align:center">
                    Bu kod <span class="shu">Shu</span> tarafından hazırlanmıştır.
                </p>
            </div>
            <a class="discord-link" href="https://discord.gg/2TYqRbZscG" target="_blank" rel="noopener noreferrer"
                aria-label="Discord sunucusuna katıl" title="Sunucuya katıl">
                <svg width="28" height="28" viewBox="0 0 245 240" xmlns="http://www.w3.org/2000/svg" role="img"
                    aria-hidden="false">
                    <path fill="#5865F2"
                        d="M104.4 104.6c-5.7 0-10.2 5-10.2 11.1 0 6.1 4.6 11.1 10.2 11.1 5.7 0 10.3-5 10.2-11.1 0-6.1-4.6-11.1-10.2-11.1zm36.2 0c-5.7 0-10.2 5-10.2 11.1 0 6.1 4.6 11.1 10.2 11.1 5.7 0 10.3-5 10.2-11.1 0-6.1-4.6-11.1-10.2-11.1z" />
                    <path fill="#5865F2"
                        d="M189.5 20H55.5C36.7 20 22 34.5 22 53.4v133.2c0 18.9 14.7 33.4 33.5 33.4h101.6l-4.8-16.8 11.6 10.9 10.9 9.9 19.4 17.9V53.4c0-18.9-14.7-33.4-33.6-33.4zm-46.1 153.4s-4.3-5.1-7.9-9.6c15.7-4.5 21.7-14.2 21.7-14.2-4.9 3.3-9.5 5.7-13.7 7.3-6 2.5-11.8 4.1-17.5 5-11.6 2.3-22.2 1.8-31.2-.1-6.8-1.4-12.7-3.5-17.6-5-2.7-0.9-5.6-2-8.5-3.4-0.4-0.2-0.9-0.4-1.3-0.6-0.3-0.1-0.4-0.2-0.6-0.3-0.1 0-0.1-0.1-0.2-0.1-0.6-0.3-0.9-0.5-0.9-0.5s6 9.5 22 14.1c-3.6 4.6-8.1 10.1-8.1 10.1-26.7-0.8-36.9-18.4-36.9-18.4 0-39 17.5-70.7 17.5-70.7 17.5-13 34.1-12.6 34.1-12.6l1.2 1.4c-21.9 6.3-32 15.8-32 15.8s2.7-1.5 7.2-3.6c13-5.9 23.2-7.5 27.4-8 0.7-0.1 1.3-0.2 2-0.3 7.6-1.7 16.2-2.6 25.1-2.6 8.9 0 17.5 0.9 25.1 2.6 0.7 0.1 1.4 0.2 2 0.3 4.2 0.5 14.4 2.1 27.4 8 4.6 2 7.3 3.6 7.3 3.6s-10.3-9.5-32.1-15.8l1.8-2.1s16.6-0.4 34.1 12.6c0 0 17.5 31.7 17.5 70.7 0 0-10.2 17.6-36.9 18.4z" />
                </svg>
            </a>
        </div>
    </div>

    <script>
        class CanvasTextEditor {
            constructor() {
                // DOM
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.manualWidth = document.getElementById('manual-width');
                this.manualHeight = document.getElementById('manual-height');
                this.bgColorInput = document.getElementById('bg-color');
                this.applyDimsBtn = document.getElementById('apply-dims');
                this.addTextBtn = document.getElementById('add-text');
                this.undoBtn = document.getElementById('undo');
                this.redoBtn = document.getElementById('redo');
                this.textsList = document.getElementById('texts-list');
                this.exportBox = document.getElementById('export-code');
                this.copyAllBtn = document.getElementById('copy-all');
                this.downloadPngBtn = document.getElementById('download-png');
                this.copyFeedback = document.getElementById('copy-feedback');

                // BG resim
                this.bgImageInput = document.getElementById('bg-image-input');
                this.applyBgImageBtn = document.getElementById('apply-bg-image');
                this.removeBgBtn = document.getElementById('remove-bg-image');
                this.bgFitSel = document.getElementById('bg-fit');
                this.bgAlpha = document.getElementById('bg-alpha');

                // Metin efektleri
                this.strokeChk = document.getElementById('text-stroke');
                this.shadowChk = document.getElementById('text-shadow');

                // State
                this.texts = [];
                this.history = [];
                this.redoStack = [];
                this.nextId = 1;
                this.dragging = false;
                this.dragTarget = null;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;
                this.selectedIndex = null;
                this.bgColor = this.bgColorInput.value || '#0f1720';
                this.maxHistory = 60;

                this.bgImage = null;
                this._bgObjectUrl = null;
                this.bgFit = 'cover';    // cover | contain | stretch
                this.bgOpacity = 1;      // 0..1

                this.textStroke = false;
                this.textShadow = false;

                // helpers
                this.debouncedSave = this.debounce(() => this.saveHistory(), 650);

                // init
                this.initEvents();
                this.addInitialTexts();
                this.saveHistory();
                this.waitForFontsThenRender();
            }

            /* ---------- helpers ---------- */
            debounce(fn, wait = 300) { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); }; }
            cssSize() {
                // Koordinat sistemi CSS pikselinde (setTransform ile ölçekleniyor)
                const w = this.canvas.clientWidth || Number(this.manualWidth.value) || 800;
                const h = this.canvas.clientHeight || Number(this.manualHeight.value) || 450;
                return { w, h };
            }
            defaultDarkColor(idx) {
                const shades = ['#111111', '#222222', '#2b2b2b', '#333333', '#3c3c3c', '#444444', '#4d4d4d'];
                return shades[(Math.max(0, idx - 1)) % shades.length];
            }
            escapeForCode(s) { return String(s).replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n'); }

            /* ---------- DPR-aware resize ---------- */
            resizeCanvasForDPR(cssW, cssH) {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.style.width = cssW + 'px';
                this.canvas.style.height = cssH + 'px';
                this.canvas.width = Math.max(1, Math.round(cssW * dpr));
                this.canvas.height = Math.max(1, Math.round(cssH * dpr));
                this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // koordinatlar CSS pikseli
            }

            /* ---------- text bounds / multi-line ---------- */
            getTextBounds(t) {
                this.ctx.font = `${t.fontSize}px ${t.fontFamily}`;
                const lines = (t.text == null) ? [''] : String(t.text).split('\n');
                const widths = lines.map(line => this.ctx.measureText(line).width || 0);
                const maxW = widths.length ? Math.max(...widths) : 0;
                const lineHeight = Math.round(t.fontSize * 1.2);
                const h = lines.length * lineHeight;
                return { width: maxW, height: h, lineHeight, lines };
            }

            /* ---------- hit test ---------- */
            hitTest(mx, my) {
                for (let i = this.texts.length - 1; i >= 0; i--) {
                    const t = this.texts[i];
                    const b = this.getTextBounds(t);
                    const left = t.x - b.width / 2;
                    const right = t.x + b.width / 2;
                    const top = t.y - b.height / 2;
                    const bottom = t.y + b.height / 2;
                    if (mx >= left && mx <= right && my >= top && my <= bottom) return i;
                }
                return null;
            }

            /* ---------- render ---------- */
            updateCanvas() {
                const { w: CW, h: CH } = this.cssSize();
                this.ctx.clearRect(0, 0, CW, CH);

                // BG
                if (this.bgImage) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.bgOpacity;

                    const iw = this.bgImage.width, ih = this.bgImage.height;
                    let dx = 0, dy = 0, dw = CW, dh = CH;
                    if (this.bgFit === 'contain' || this.bgFit === 'cover') {
                        const s = (this.bgFit === 'contain') ? Math.min(CW / iw, CH / ih) : Math.max(CW / iw, CH / ih);
                        dw = Math.round(iw * s);
                        dh = Math.round(ih * s);
                        dx = Math.round((CW - dw) / 2);
                        dy = Math.round((CH - dh) / 2);
                    }
                    // stretch default: dx,dy=0; dw,dh=CW,CH
                    this.ctx.drawImage(this.bgImage, dx, dy, dw, dh);
                    this.ctx.restore();
                } else {
                    this.ctx.fillStyle = this.bgColor || '#0f1720';
                    this.ctx.fillRect(0, 0, CW, CH);
                }

                // Metinler
                this.texts.forEach((t, i) => {
                    this.ctx.font = `${t.fontSize}px ${t.fontFamily}`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    // Shadow
                    if (this.textShadow) {
                        this.ctx.shadowColor = 'rgba(0,0,0,0.6)';
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowOffsetY = 2;
                    }

                    const bounds = this.getTextBounds(t);
                    const startY = t.y - bounds.height / 2 + bounds.lineHeight / 2;

                    this.ctx.fillStyle = t.color;
                    bounds.lines.forEach((line, idx) => {
                        const y = startY + idx * bounds.lineHeight;
                        this.ctx.fillText(line, t.x, y);
                        if (this.textStroke) {
                            this.ctx.lineWidth = Math.max(1, Math.round(t.fontSize * 0.04));
                            this.ctx.strokeStyle = 'rgba(0,0,0,0.85)';
                            this.ctx.strokeText(line, t.x, y);
                        }
                    });

                    if (this.textShadow) {
                        this.ctx.shadowColor = 'transparent';
                        this.ctx.shadowBlur = 0;
                        this.ctx.shadowOffsetY = 0;
                    }
                });

                // Seçili öğe çerçevesi
                if (this.selectedIndex != null && this.texts[this.selectedIndex]) {
                    const t = this.texts[this.selectedIndex];
                    const b = this.getTextBounds(t);
                    const left = Math.round(t.x - b.width / 2);
                    const top = Math.round(t.y - b.height / 2);
                    this.ctx.save();
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(left, top, Math.max(1, b.width), Math.max(1, b.height));
                    this.ctx.restore();
                }

                this.refreshExportCode();
                this.syncListPositions();
            }

            /* ---------- UI list render ---------- */
            renderTextList() {
                this.textsList.innerHTML = '';
                this.texts.forEach((t, i) => {
                    const div = document.createElement('div');
                    div.className = 'text-item';
                    div.dataset.id = t.id;

                    // header
                    const header = document.createElement('div');
                    header.style.display = 'flex';
                    header.style.gap = '12px';
                    header.style.alignItems = 'center';

                    const strong = document.createElement('strong');
                    strong.textContent = `Metin ${i + 1}`;
                    header.appendChild(strong);

                    const filler = document.createElement('div'); filler.style.flex = '1';
                    header.appendChild(filler);

                    const centerBtn = document.createElement('button');
                    centerBtn.className = 'small-btn grey';
                    centerBtn.textContent = 'Ortala';
                    centerBtn.dataset.action = 'center';
                    centerBtn.title = 'Merkeze hizala';
                    header.appendChild(centerBtn);

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'small-btn';
                    removeBtn.textContent = 'Sil';
                    removeBtn.dataset.action = 'remove';
                    removeBtn.title = 'Metni sil';
                    header.appendChild(removeBtn);

                    div.appendChild(header);

                    // textarea
                    const lbl = document.createElement('label'); lbl.textContent = 'İçerik:'; div.appendChild(lbl);
                    const ta = document.createElement('textarea');
                    ta.dataset.field = 'text'; ta.rows = 2; ta.value = t.text; ta.style.marginTop = '6px';
                    div.appendChild(ta);

                    // font size + family
                    const row = document.createElement('div'); row.className = 'row'; row.style.marginTop = '8px';
                    const fs = document.createElement('input'); fs.className = 'half'; fs.dataset.field = 'fontSize'; fs.type = 'number'; fs.min = 8; fs.max = 400; fs.value = t.fontSize;
                    const ff = document.createElement('select'); ff.className = 'half'; ff.dataset.field = 'fontFamily';
                    ['Roboto', 'Open Sans', 'Inter', 'Arial', 'Helvetica', 'Times New Roman', 'Courier New'].forEach(opt => {
                        const o = document.createElement('option'); o.textContent = opt; if (opt === t.fontFamily) o.selected = true; ff.appendChild(o);
                    });
                    row.appendChild(fs); row.appendChild(ff);
                    div.appendChild(row);

                    // color
                    const lblc = document.createElement('label'); lblc.textContent = 'Renk'; lblc.style.marginTop = '10px';
                    div.appendChild(lblc);
                    const colorInp = document.createElement('input'); colorInp.type = 'color'; colorInp.dataset.field = 'color'; colorInp.value = t.color; colorInp.style.marginTop = '6px';
                    div.appendChild(colorInp);

                    // position x,y
                    const lblpos = document.createElement('label'); lblpos.textContent = 'Pozisyon (x, y)'; lblpos.style.marginTop = '10px';
                    div.appendChild(lblpos);
                    const row2 = document.createElement('div'); row2.className = 'row';
                    const xin = document.createElement('input'); xin.dataset.field = 'x'; xin.type = 'number'; xin.value = Math.round(t.x);
                    const yin = document.createElement('input'); yin.dataset.field = 'y'; yin.type = 'number'; yin.value = Math.round(t.y);
                    row2.appendChild(xin); row2.appendChild(yin);
                    div.appendChild(row2);

                    this.textsList.appendChild(div);
                });
            }

            /* ---------- sync positions ---------- */
            syncListPositions() {
                const items = this.textsList.querySelectorAll('.text-item');
                items.forEach(item => {
                    const id = Number(item.dataset.id);
                    const t = this.texts.find(x => x.id === id);
                    if (!t) return;
                    const xin = item.querySelector('input[data-field="x"]');
                    const yin = item.querySelector('input[data-field="y"]');
                    if (document.activeElement !== xin) xin.value = Math.round(t.x);
                    if (document.activeElement !== yin) yin.value = Math.round(t.y);
                });
            }

            /* ---------- export code ---------- */
            refreshExportCode() {
                const outW = Number(this.manualWidth.value) || 800;
                const outH = Number(this.manualHeight.value) || 450;

                const lines = [
                    "// Discord.js Canvas Example (node-canvas)",
                    "const { createCanvas, registerFont, loadImage } = require('canvas');",
                    `const canvas = createCanvas(${outW}, ${outH});`,
                    "const ctx = canvas.getContext('2d');",
                    "",
                    "// İsteğe bağlı: fontlar sistemde yoksa kaydedin",
                    "// registerFont('./fonts/Roboto-Regular.ttf', { family: 'Roboto' });",
                    "",
                    `ctx.fillStyle = '${this.bgColor}';`,
                    `ctx.fillRect(0, 0, ${outW}, ${outH});`,
                    "",
                    "// Çok satırlı merkezli çizim helper",
                    "function drawMultilineCentered(ctx, text, x, y, fontSize, color, stroke=false, shadow=false){",
                    "  const lines = String(text).split('\\n');",
                    "  const lineHeight = Math.round(fontSize * 1.2);",
                    "  const totalH = lines.length * lineHeight;",
                    "  let cy = y - totalH/2 + lineHeight/2;",
                    "  ctx.textAlign = 'center';",
                    "  ctx.textBaseline = 'middle';",
                    "  ctx.fillStyle = color;",
                    "  if (shadow){ ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=8; ctx.shadowOffsetY=2; }",
                    "  for(const ln of lines){",
                    "    ctx.fillText(ln, x, cy);",
                    "    if (stroke){ ctx.lineWidth=Math.max(1, Math.round(fontSize*0.04)); ctx.strokeStyle='rgba(0,0,0,0.85)'; ctx.strokeText(ln, x, cy); }",
                    "    cy += lineHeight;",
                    "  }",
                    "  if (shadow){ ctx.shadowColor='transparent'; ctx.shadowBlur=0; ctx.shadowOffsetY=0; }",
                    "}",
                    ""
                ];

                this.texts.forEach(t => {
                    const safeText = this.escapeForCode(t.text);
                    lines.push(`ctx.font = '${t.fontSize}px ${t.fontFamily}';`);
                    lines.push(`drawMultilineCentered(ctx, '${safeText}', ${Math.round(t.x)}, ${Math.round(t.y)}, ${t.fontSize}, '${t.color}', ${this.textStroke}, ${this.textShadow});`);
                    lines.push('');
                });

                lines.push("// Sonuç: canvas.toBuffer(), canvas.createPNGStream(), vs.");
                this.exportBox.textContent = lines.join('\n');
            }

            /* ---------- history ---------- */
            saveHistory() {
                const snapshot = {
                    texts: JSON.parse(JSON.stringify(this.texts)),
                    bgColor: this.bgColor,
                    nextId: this.nextId,
                    canvasW: Number(this.manualWidth.value) || Math.round(this.canvas.clientWidth),
                    canvasH: Number(this.manualHeight.value) || Math.round(this.canvas.clientHeight),
                    bgFit: this.bgFit,
                    bgOpacity: this.bgOpacity,
                    hasBgImage: !!this.bgImage,
                    textStroke: this.textStroke,
                    textShadow: this.textShadow
                };
                this.history.push(JSON.stringify(snapshot));
                if (this.history.length > this.maxHistory) this.history.shift();
                this.redoStack = [];
                this.updateUndoRedoButtons();
            }

            undo() {
                if (this.history.length <= 1) return;
                this.redoStack.push(this.history.pop());
                const prev = JSON.parse(this.history[this.history.length - 1]);
                this.applySnapshot(prev);
            }

            redo() {
                if (this.redoStack.length === 0) return;
                const snap = this.redoStack.pop();
                this.history.push(snap);
                const cur = JSON.parse(snap);
                this.applySnapshot(cur);
            }

            applySnapshot(snap) {
                this.texts = snap.texts || [];
                this.bgColor = snap.bgColor || this.bgColor;
                this.nextId = snap.nextId || this.nextId;
                this.bgFit = snap.bgFit || this.bgFit;
                this.bgOpacity = (typeof snap.bgOpacity === 'number') ? snap.bgOpacity : this.bgOpacity;
                this.textStroke = !!snap.textStroke;
                this.textShadow = !!snap.textShadow;

                this.bgFitSel.value = this.bgFit;
                this.bgAlpha.value = String(this.bgOpacity);
                this.strokeChk.checked = this.textStroke;
                this.shadowChk.checked = this.textShadow;

                const w = snap.canvasW || Number(this.manualWidth.value);
                const h = snap.canvasH || Number(this.manualHeight.value);
                this.manualWidth.value = w; this.manualHeight.value = h;
                this.resizeCanvasForDPR(w, h);
                this.renderTextList();
                this.updateCanvas();
                this.updateUndoRedoButtons();
            }

            updateUndoRedoButtons() {
                this.undoBtn.disabled = this.history.length <= 1;
                this.redoBtn.disabled = this.redoStack.length === 0;
            }

            /* ---------- events ---------- */
            initEvents() {
                // Canvas drag & select
                this.canvas.addEventListener('mousedown', (ev) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mx = ev.clientX - rect.left;
                    const my = ev.clientY - rect.top;
                    const hit = this.hitTest(mx, my);
                    if (hit !== null) {
                        this.dragging = true;
                        this.dragTarget = hit;
                        this.selectedIndex = hit;
                        const t = this.texts[hit];
                        this.dragOffsetX = mx - t.x;
                        this.dragOffsetY = my - t.y;
                        this.canvas.style.cursor = 'grabbing';
                    } else {
                        this.selectedIndex = null;
                    }
                    this.updateCanvas();
                });

                window.addEventListener('mousemove', (ev) => {
                    if (!this.dragging || this.dragTarget === null) return;
                    const rect = this.canvas.getBoundingClientRect();
                    const mx = ev.clientX - rect.left;
                    const my = ev.clientY - rect.top;
                    const t = this.texts[this.dragTarget];
                    const { w: CW, h: CH } = this.cssSize();
                    t.x = Math.max(0, Math.min(CW, mx - this.dragOffsetX));
                    t.y = Math.max(0, Math.min(CH, my - this.dragOffsetY));
                    this.updateCanvas();
                });

                window.addEventListener('mouseup', () => {
                    if (!this.dragging) return;
                    this.dragging = false;
                    this.dragTarget = null;
                    this.canvas.style.cursor = 'grab';
                    this.updateCanvas();
                    this.saveHistory();
                });

                // Klavye kısayolları
                window.addEventListener('keydown', (e) => {
                    const mod = e.ctrlKey || e.metaKey;
                    if (mod && (e.key.toLowerCase() === 'z')) {
                        e.preventDefault();
                        if (e.shiftKey) this.redo(); else this.undo();
                        return;
                    }
                    if (mod && (e.key.toLowerCase() === 'y')) {
                        e.preventDefault();
                        this.redo();
                        return;
                    }

                    const sel = (this.selectedIndex != null) ? this.texts[this.selectedIndex] : null;
                    if (!sel) return;

                    const step = e.shiftKey ? 10 : 1;
                    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Delete', 'Backspace'].includes(e.key)) e.preventDefault();

                    const { w: CW, h: CH } = this.cssSize();
                    if (e.key === 'ArrowLeft') sel.x = Math.max(0, sel.x - step);
                    if (e.key === 'ArrowRight') sel.x = Math.min(CW, sel.x + step);
                    if (e.key === 'ArrowUp') sel.y = Math.max(0, sel.y - step);
                    if (e.key === 'ArrowDown') sel.y = Math.min(CH, sel.y + step);
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        this.texts.splice(this.selectedIndex, 1);
                        this.selectedIndex = null;
                    }
                    this.updateCanvas();
                    this.debouncedSave();
                });

                // Liste içi inputlar
                this.textsList.addEventListener('input', (ev) => {
                    const el = ev.target;
                    const parent = el.closest('.text-item');
                    if (!parent) return;
                    const id = Number(parent.dataset.id);
                    const t = this.texts.find(x => x.id === id);
                    if (!t) return;
                    const field = el.dataset.field;
                    if (field === 'text') { t.text = el.value; }
                    else if (field === 'fontSize') { t.fontSize = Math.max(8, Math.min(400, Number(el.value) || 36)); }
                    else if (field === 'fontFamily') { t.fontFamily = el.value; }
                    else if (field === 'color') { t.color = el.value; }
                    else if (field === 'x') {
                        const { w: CW } = this.cssSize();
                        t.x = Math.max(0, Math.min(CW, Number(el.value) || 0));
                    }
                    else if (field === 'y') {
                        const { h: CH } = this.cssSize();
                        t.y = Math.max(0, Math.min(CH, Number(el.value) || 0));
                    }
                    this.updateCanvas();
                    this.debouncedSave();
                });

                // Liste butonları
                this.textsList.addEventListener('click', (ev) => {
                    const btn = ev.target.closest('button');
                    if (!btn) return;
                    const item = btn.closest('.text-item');
                    const id = Number(item.dataset.id);
                    const idx = this.texts.findIndex(x => x.id === id);
                    if (btn.dataset.action === 'remove') {
                        if (idx >= 0) {
                            this.texts.splice(idx, 1);
                            if (this.selectedIndex === idx) this.selectedIndex = null;
                            this.renderTextList(); this.updateCanvas(); this.saveHistory();
                        }
                    } else if (btn.dataset.action === 'center') {
                        if (idx >= 0) {
                            const { w: CW, h: CH } = this.cssSize();
                            this.texts[idx].x = CW / 2;
                            this.texts[idx].y = CH / 2;
                            this.selectedIndex = idx;
                            this.updateCanvas(); this.saveHistory();
                        }
                    }
                });

                // Metin ekle
                this.addTextBtn.addEventListener('click', () => {
                    const custom = prompt('İçerik:', 'Ben Bir Muzum');
                    if (custom !== null && custom !== undefined) {
                        this.addNewText({ text: custom });
                        this.saveHistory();
                    }
                });

                // Boyut uygula
                this.applyDimsBtn.addEventListener('click', () => {
                    const w = Math.max(50, Math.min(3000, Number(this.manualWidth.value) || 800));
                    const h = Math.max(30, Math.min(3000, Number(this.manualHeight.value) || 450));
                    const prev = this.cssSize();
                    const rels = this.texts.map(t => ({ x: t.x / prev.w, y: t.y / prev.h }));
                    this.resizeCanvasForDPR(w, h);
                    this.texts.forEach((t, i) => {
                        t.x = Math.round(Math.max(0, Math.min(w, (rels[i].x * w) || w / 2)));
                        t.y = Math.round(Math.max(0, Math.min(h, (rels[i].y * h) || h / 2)));
                    });
                    this.updateCanvas();
                    this.saveHistory();
                });

                // BG renk
                this.bgColorInput.addEventListener('input', (ev) => {
                    this.bgColor = ev.target.value;
                    if (!this.bgImage) { this.updateCanvas(); this.debouncedSave(); }
                });

                // Undo/Redo butonları
                this.undoBtn.addEventListener('click', () => this.undo());
                this.redoBtn.addEventListener('click', () => this.redo());

                // Kopyala (export)
                this.copyAllBtn.addEventListener('click', async () => {
                    const txt = this.exportBox.textContent;
                    try {
                        await navigator.clipboard.writeText(txt);
                        this.copyFeedback.style.display = 'block';
                        setTimeout(() => this.copyFeedback.style.display = 'none', 1500);
                    } catch {
                        const ta = document.createElement('textarea'); ta.value = txt;
                        document.body.appendChild(ta); ta.select();
                        try { document.execCommand('copy'); this.copyFeedback.style.display = 'block'; setTimeout(() => this.copyFeedback.style.display = 'none', 1500); }
                        catch { alert('Kopyalama başarısız.'); }
                        document.body.removeChild(ta);
                    }
                });

                // PNG indir
                this.downloadPngBtn.addEventListener('click', () => {
                    const link = document.createElement('a');
                    link.download = 'canvas-text.png';
                    link.href = this.canvas.toDataURL('image/png');
                    link.click();
                });

                // BG resim ekle
                this.applyBgImageBtn.addEventListener('click', () => {
                    const file = this.bgImageInput.files[0];
                    if (!file) return alert('Lütfen bir resim seçin.');
                    const img = new Image();
                    img.onload = () => {
                        this.bgImage = img;
                        this.updateCanvas();
                        this.saveHistory();
                    };
                    img.onerror = () => alert('Resim yüklenemedi.');
                    if (this._bgObjectUrl) URL.revokeObjectURL(this._bgObjectUrl);
                    this._bgObjectUrl = URL.createObjectURL(file);
                    img.src = this._bgObjectUrl;
                });

                // BG resim kaldır
                this.removeBgBtn.addEventListener('click', () => {
                    if (this._bgObjectUrl) { URL.revokeObjectURL(this._bgObjectUrl); this._bgObjectUrl = null; }
                    this.bgImage = null;
                    this.updateCanvas();
                    this.saveHistory();
                });

                // BG fit/alpha
                this.bgFitSel.addEventListener('change', e => { this.bgFit = e.target.value; this.updateCanvas(); this.debouncedSave(); });
                this.bgAlpha.addEventListener('input', e => { this.bgOpacity = Number(e.target.value); this.updateCanvas(); this.debouncedSave(); });

                // Stroke/Shadow toggles
                this.strokeChk.addEventListener('change', e => { this.textStroke = e.target.checked; this.updateCanvas(); this.debouncedSave(); });
                this.shadowChk.addEventListener('change', e => { this.textShadow = e.target.checked; this.updateCanvas(); this.debouncedSave(); });

                // Canvas focus için klavye yakalama
                this.canvas.addEventListener('click', () => this.canvas.focus());
            }

            /* ---------- text management ---------- */
            addNewText(custom = {}) {
                const idx = this.texts.length;
                const { w: CW, h: CH } = this.cssSize();
                const colorDefault = (idx === 0 ? '#000000' : this.defaultDarkColor(idx));
                const t = {
                    id: this.nextId++,
                    text: custom.text ?? `Ben Bir Muzum ${idx + 1}`,
                    x: custom.x ?? Math.round(CW / 2),
                    y: custom.y ?? Math.round(CH / 2) + idx * 30,
                    fontSize: custom.fontSize ?? 36,
                    color: custom.color ?? colorDefault,
                    fontFamily: custom.fontFamily ?? 'Roboto'
                };
                this.texts.push(t);
                this.selectedIndex = this.texts.length - 1;
                this.renderTextList();
                this.updateCanvas();
            }

            addInitialTexts() {
                // İlk metin siyah (kontrast için BG açıkken beyaz istenirse custom.color verilebilir)
                this.addNewText({ text: 'Ben Bir Muzum', fontSize: 56 });
            }

            /* ---------- font load wait ---------- */
            waitForFontsThenRender() {
                const w = Number(this.manualWidth.value) || 800;
                const h = Number(this.manualHeight.value) || 450;
                if (document.fonts && document.fonts.ready) {
                    document.fonts.ready.then(() => {
                        this.resizeCanvasForDPR(w, h);
                        this.updateCanvas();
                    }).catch(() => { this.resizeCanvasForDPR(w, h); this.updateCanvas(); });
                } else {
                    this.resizeCanvasForDPR(w, h);
                    this.updateCanvas();
                }
            }
        }

        // instantiate
        const editor = new CanvasTextEditor();
    </script>
</body>

</html>
